/* 
Copyright (c) 2009-2010 Konnetic Ltd.
*/
/* Change history
* 20 Jan 2010  James Wright james@konnetic.com Baseline Implementation
*/

using System;
using System.ComponentModel;
using System.Globalization;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

namespace Konnetic.Sip.Headers
{
    /// <summary>A Contact HeaderField value provides a URI whose meaning depends on the type of <see cref="T:Konnetic.Sip.Messages.Response"/> or <see cref="T:Konnetic.Sip.Messages.Request"/> it is in. A Contact HeaderField value can contain a display name, a URI with URI parameters, and header parameters.
    /// </summary>
    /// <remarks>
    /// <b>Standards: RFC3261</b>
    /// The optional display-name is meant to be rendered by a human user interface. Even if the display-name is empty, the name-addr form must be used if the addr-spec contains a comma, question mark, or semicolon.
    /// <para/>
    /// The display name can be tokens, or a quoted string, if a larger character set is desired. Even if the display-name is empty, the name-addr form must be used if the addr-spec contains a comma, semicolon, or question mark. There may or may not be WHITESPACE between the display-name and the "&lt;". These rules for parsing a display name, URI and URI parameters, and header parameters also apply for the HeaderFields To and From.
    /// <b>Parameters</b>
    /// <para/>
    /// When the HeaderField value contains a display name, the URI including all URI parameters is enclosed in "&lt;" and "&gt;". If no "&lt;" and "&gt;" are present, all parameters after the URI are header parameters, not URI parameters. This document defines the Contact parameters q and expires. These parameters are only used when the Contact is present in a REGISTER <see cref="T:Konnetic.Sip.Messages.Request"/> or <see cref="T:Konnetic.Sip.Messages.Response"/>, or in a 3xx response. Additional parameters may be defined in other specifications.
    /// <para/>
    /// <b>URI</b>
    /// The Contact, From, and To HeaderFields contain a URI. If the URI contains a comma, question mark or semicolon, the URI must be enclosed in angle brackets (&lt; and &gt;). Any URI parameters are contained within these brackets. If the URI is not enclosed in angle brackets, any semicolon-delimited parameters are header-parameters, not URI parameters.
    /// <para/>
    /// <b>Tag Parameter</b>
    /// <para/>
    /// The tag parameter is used in the To and From HeaderFields of SIP messages. It serves as a general mechanism to identify a dialog, which is the combination of the Call-ID along with two tags, one from each participant in the dialog. When a client sends a request outside of a dialog, it contains a From tag only, providing "half" of the dialog ID. The dialog is completed from the response(s), each of which contributes the second half in the To HeaderField. The forking of SIP requests means that multiple dialogs can be established from a single request. This also explains the need for the two-sided dialog identifier; without a contribution from the recipients, the originator could not disambiguate the multiple dialogs established from a single request.
    /// <para/>
    /// When a tag is generated by a client for insertion into a request or response, it must be globally unique and cryptographically random with at least 32 bits of randomness. A property of this selection requirement is that a client will place a different tag into the From header of an INVITE than it would place into the To header of the response to the same INVITE. This is needed in order for a client to invite itself to a session, a common case for "hairpinning" of calls in PSTN gateways. Similarly, two INVITEs for different calls will have different From tags, and two responses for different calls will have different To tags. 
    /// <para/>
    /// Besides the requirement for global uniqueness, the algorithm for generating a tag is implementation-specific. Tags are helpful in fault tolerant systems, where a dialog is to be recovered on an alternate server after a failure. A server can select the tag in such a way that a backup can recognize a request as part of a dialog on the failed server, and therefore determine that it should attempt to recover the dialog and any other state associated with it.
    /// <para/>
    /// <b>RFC 3261 Syntax:</b> 
    /// <table >
    /// <tr><td colspan="2" style="border-bottom:none">("Contact" / "m" ) ":" ( STAR / (contact-param *("," contact-param)))</td></tr>
    /// <tr><td style="border-bottom:none">contact-param = </td><td style="border-bottom:none">(name-addr / addr-spec) *(SEMI contact-params)</td></tr>
    /// <tr><td style="border-bottom:none">name-addr = </td><td style="border-bottom:none">[ display-name ] &lt; addr-spec &gt;</td></tr>
    /// <tr><td style="border-bottom:none">addr-spec = </td><td style="border-bottom:none">SIP-URI / SIPS-URI / absoluteURI</td></tr>
    /// <tr><td style="border-bottom:none">display-name = </td><td style="border-bottom:none">*(token LWS)/ quoted-string</td></tr>
    /// <tr><td style="border-bottom:none">token = </td><td style="border-bottom:none">1*(alphanum / "-" / "." / "!" / "%" / "*" / "_" / "+" / "‘" / "'" / "˜" )</td></tr>
    /// <tr><td style="border-bottom:none">quoted-string = </td><td style="border-bottom:none">SWS DOUBLE_QUOTE *(qdtext / quoted-pair ) DOUBLE_QUOTE</td></tr>
    /// <tr><td style="border-bottom:none">qdtext = </td><td style="border-bottom:none">LWS / %x21 / %x23-5B / %x5D-7E / UTF8-NONASCII</td></tr>
    /// <tr><td style="border-bottom:none">LWS = </td><td style="border-bottom:none">[*WSP CRLF] 1*WSP ; linear whitespace</td></tr>
    /// <tr><td style="border-bottom:none">SWS = </td><td style="border-bottom:none">[LWS] ; sep whitespace</td></tr>
    /// <tr><td style="border-bottom:none">host = </td><td style="border-bottom:none">hostname / IPv4address / IPv6reference</td></tr>
    /// </table>
    /// <para/>
    /// <note type="implementnotes">The compact form of the Contact HeaderField is "m" (for "moved").</note> 
    /// <para/>
    /// <note type="implementnotes">This HeaderField allows HeaderField grouping (<see cref="T:Konnetic.Sip.Headers.HeaderFieldGroup{T}"/>).</note> 
    /// <example>
    /// <list type="bullet">
    /// <item>Contact: "Mr. Watson" &lt;sip:watson@worcester.bell-telephone.co&gt; ;q=0.7; expires=3600, "Mr. Watson" &lt;mailto:watson@bell-telephone.com&gt; ;q=0.1</item> 
    /// <item>m: &lt;sips:bob@192.0.2.4&gt;expires=60</item> 
    /// </list> 
    /// </example>
    /// </remarks>
    /// <seealso cref="T:Konnetic.Sip.Headers.AddressedHeaderFieldBase"/>
    /// <seealso cref="T:Konnetic.Sip.Headers.ToHeaderFieldBase"/>
    /// <seealso cref="T:Konnetic.Sip.Headers.FromEncodingHeaderField"/> 
    public sealed class ContactHeaderField : AddressedHeaderFieldBase
    {
        #region Fields

        internal const string CompareName = "CONTACT";
        internal const string CompareShortName = "M";

        /// <summary>¬
        /// The long form of the name.
        /// </summary>
        internal const string LongName = "Contact";

        /// <summary>
        /// The short form of the name.
        /// </summary>
        internal const string ShortName = "m";

        #endregion Fields

        #region Properties
        /// <summary>
        /// Gets the generic parameters.
        /// </summary>
        /// <value>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection<SipParameter>"/> field parameter.</value>
        public System.Collections.ObjectModel.ReadOnlyCollection<SipParameter> GenericParameters
            {
            get { return InternalGenericParameters; }
            }
        /// <summary>
        /// Adds the parameter.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="value">The value.</param>
        public void AddParameter(string name, string value)
            {
            InternalAddGenericParameter(name, value);
            }
        /// <summary>
        /// Adds the parameter.
        /// </summary>
        /// <param name="parameter">The parameter.</param>
        public void AddParameter(SipParameter parameter)
            {
            InternalAddGenericParameter(parameter);
            }
        /// <summary>
        /// Gets or sets the expires.
        /// </summary>
        /// <remarks>Set value to null to remove from header.</remarks>
        /// <value>The expires.</value>
        public int? Expires
        {
            get {
            SipParameter sp = HeaderParameters["expires"];

            if((object)sp == null)
                {
                return null;
                }
            try
                {
                return Int32.Parse(sp.Value, CultureInfo.InvariantCulture);
                }
            catch(FormatException ex)
                {
                throw new SipFormatException("Cannot convert Expires to an integer", ex);
                }
            catch(OverflowException ex)
                {
                throw new SipOutOfRangeException("Expires", SR.GetString(SR.OutOfRangeException, sp.Value, "Expires", 0, int.MaxValue), ex);  
                }
            }
            set
                {
                if(value == null || value<0)
                    {
                    RemoveParameter("expires");
                    }
                else
                    {
                    HeaderParameters.Set("expires", ((int)value).ToString(CultureInfo.InvariantCulture));
                    }

                }
        }

        /// <summary>
        /// Gets or sets the Q value.
        /// </summary>
        /// <remarks>Set value to null to remove from Header field.
        /// <note type="caution">"Quality values" is a misnomer, since these values merely represent relative degradation in desired quality.</note> </remarks>
        /// <value>The Q value.</value>
        public float? QValue
        {
            get
                {
                SipParameter sp = HeaderParameters["q"];

                if((object)sp == null)
                    {
                    return null;
                    }
                try{
                    
                    float val = float.Parse(sp.Value, NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
                    PropertyVerifier.ThrowIfFloatOutOfRange(val, 0f, 1f, "'Q'");
                    return val;
                    }
                catch(FormatException ex)
                    {
                    throw new SipException(SR.GetString(SR.FloatConvertException, sp.Value, "QValue"), ex); 
                    }
                catch(ArgumentException ex)
                    {
                    throw new SipException(SR.GetString(SR.FloatConvertException, sp.Value, "QValue"), ex);  
                    }
                }
            set
            {
                if(value==null)
                    { 
                    RemoveParameter("q");
                    }
                else
                    {
                    PropertyVerifier.ThrowIfFloatOutOfRange(value, 0f, 1f, "'Q'");
                    HeaderParameters.Set(0, "q", ((float)value).ToString("0.###", CultureInfo.InvariantCulture));
                    }

                }
        }

        #endregion Properties

        #region Constructors

		/// <summary>
		/// Initializes a new instance of the <see cref="ContactHeaderField"/> class.
		/// </summary>
		/// <remarks>The default constructor.</remarks>
		/// <overloads>
		/// <summary>The method has three overloads.</summary>
		/// </overloads>
		public ContactHeaderField()
			: base()
			{
			Init();
			}
        /// <summary>
        /// Initializes a new instance of the <see cref="ContactHeaderField"/> class.
        /// </summary>
        /// <param name="uri"></param>
        public ContactHeaderField(string uri)
            : this(new SipUri(uri))
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ContactHeaderField"/> class.
        /// </summary>
        /// <param name="uri">The URI.</param>
        public ContactHeaderField(SipUri uri)
            : this(uri, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ContactHeaderField"/> class.
        /// </summary>
        /// <param name="uri">The URI.</param>
        /// <param name="displayName">The display name.</param>
        public ContactHeaderField(SipUri uri, string displayName)
            : base(uri, displayName)
        {
            Init();
        }

        #endregion Constructors

        #region Methods

		/// <summary>
		/// Performs an implicit conversion from <see cref="System.String"/> to <see cref="Konnetic.Sip.Headers.ContactHeaderField"/>.
		/// </summary>
		/// <param name="value">The string value representing the HeaderField.</param>
        /// <returns>A new <see cref="Konnetic.Sip.Headers.ContactHeaderField"/> populated from the <paramref name="value"/> parameter.</returns>
        /// <threadsafety static="true" instance="false" /> 
        /// <exception cref="ArgumentNullException">Thrown on null (<b>Nothing</b> in Visual Basic) <paramref name="value"/>.</exception>
        public static implicit operator ContactHeaderField(String value)
        {
            PropertyVerifier.ThrowOnNullArgument(value,"value");

            ContactHeaderField hf = new ContactHeaderField();
            hf.Parse(value);
            return hf;
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="Konnetic.Sip.Headers.ContactHeaderField"/> to <see cref="System.String"/>.
		/// </summary>
		/// <param name="headerField">The HeaderField to convert.</param>
		/// <returns>A string representation of the HeaderField.</returns>
        /// <exception cref="ArgumentNullException">Thrown on null (<b>Nothing</b> in Visual Basic) <paramref name="headerField"/>.</exception>
        /// <threadsafety static="true" instance="false" /> 
        public static explicit operator string(ContactHeaderField headerField)
        {
            PropertyVerifier.ThrowOnNullArgument(headerField, "headerField");
            return headerField.ToString();
        }

        /// <summary>
        /// Creates a deap  copy of this instance.
        /// </summary> 
        /// <remarks>Creates and returns a deep copy of the Header. This method ensures a deep copy of the HeaderField, when a message is cloned the HeaderField can be modified without effecting the original HeaderField in the message.</remarks>
        /// <returns>A deep copy of <see cref="T:Konnetic.Sip.Headers.ContactHeaderField"/>.</returns>
        /// <threadsafety static="true" instance="false" /> 
public override HeaderFieldBase Clone()
        {
        ContactHeaderField newObj = new ContactHeaderField(Uri, DisplayName);
        CopyParametersTo(newObj); 
            newObj.UriSet = UriSet;
            return newObj;
        }
/// <summary>
/// Compare this SIP Header for equality with another <see cref="T:Konnetic.Sip.Headers.ContactHeaderField"/> object.</summary>
/// <remarks>
/// All optional headers are compared using object equality that is each field in the header is used for comparision. When comparing HeaderFields, field names are always case-insensitive. Unless otherwise stated in the definition of a particular HeaderField, field values, parameter names, and parameter values are case-insensitive. Tokens are always case-insensitive. Unless specified otherwise, values expressed as quoted strings are case-sensitive. 
/// </remarks>
/// <param name="other">The <see cref="T:Konnetic.Sip.Headers.ContactHeaderField"/> to compare to this instance.</param>
/// <returns><c>true</c> if <paramref name="other" /> is an instance of this class representing the same SIP HeaderField as this, <c>false</c> otherwise.</returns>    
/// <overloads>
/// <summary>This method is overloaded.</summary>
/// <remarks>Overloads allow for equality against <see cref="T:Konnetic.Sip.Headers.HeaderFieldBase"/>, <see cref="T:System.Object"/> and another instance of this HeaderField.</remarks>
/// </overloads>  
/// <threadsafety static="true" instance="false" />
[return: System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.U1)]
public bool Equals(ContactHeaderField other)
    {
    if((object)other == null)
        {
        return false;
        }
    if(QValue.HasValue && other.QValue.HasValue)
        {
        return base.Equals((SipUriHeaderFieldBase)other) && Math.Abs((float)QValue - (float)other.QValue) < 0.001;
        }
    else
        {
        return base.Equals((SipUriHeaderFieldBase)other) && QValue.Equals(other.QValue);
        }
    }

/// <summary>Compare this SIP Header for equality with the base <see cref="T:Konnetic.Sip.Headers.HeaderFieldBase"/>.
/// </summary>
/// <remarks>This method overrides the <c>equals</c> method in <see cref="T:Konnetic.Sip.Headers.HeaderFieldBase"/>. 
/// All optional headers are compared using object equality that is each field in the header is used for comparision. When comparing HeaderFields, field names are always case-insensitive. Unless otherwise stated in the definition of a particular HeaderField, field values, parameter names, and parameter values are case-insensitive. Tokens are always case-insensitive. Unless specified otherwise, values expressed as quoted strings are case-sensitive. 
/// </remarks>
/// <param name="other">The <see cref="T:Konnetic.Sip.Headers.HeaderFieldBase"/> to compare to this instance.</param>
/// <returns><c>true</c> if <paramref name="other" /> is an instance of this class representing the same SIP HeaderField as this, <c>false</c> otherwise.</returns>
/// <overloads>
/// <summary>This method is overloaded.</summary>
/// <remarks>Overloads allow for equality against <see cref="T:Konnetic.Sip.Headers.HeaderFieldBase"/>, <see cref="T:System.Object"/> and another instance of this HeaderField.</remarks>
/// </overloads>  
/// <threadsafety static="true" instance="false" /> 
        [return: System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.U1)]
        public override bool Equals(HeaderFieldBase other)
        {
            return Equals((object)other);
        }

 
        /// <summary>Compare this SIP Header for equality with an instance of <see cref="T:System.Object"/>.
        /// </summary>
        /// <remarks>This method overrides the <c>equals</c> method in <see cref="System.Object"/>. 
        /// All optional headers are compared using object equality that is each field in the header is used for comparision. When comparing HeaderFields, field names are always case-insensitive. Unless otherwise stated in the definition of a particular HeaderField, field values, parameter names, and parameter values are case-insensitive. Tokens are always case-insensitive. Unless specified otherwise, values expressed as quoted strings are case-sensitive. 
        /// </remarks>
        /// <param name="obj">The <see cref="T:System.Object"/> to compare to this instance.</param>
        /// <returns><c>true</c> if <paramref name="obj" /> is an instance of this class representing the same SIP HeaderField as this, <c>false</c> otherwise. </returns>        
        /// <overloads>
        /// <summary>This method is overloaded.</summary>
        /// <remarks>Overloads allow for equality against <see cref="T:Konnetic.Sip.Headers.HeaderFieldBase"/>, <see cref="T:System.Object"/> and another instance of this HeaderField.</remarks>
        /// </overloads> 
        /// <threadsafety static="true" instance="false" />
        [return: System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.U1)]
        public override bool Equals(object obj)
        {
            if(obj == null)
                {
                return false;
                }

            ContactHeaderField p1 = obj as ContactHeaderField;
            if((object)p1 == null)
                {
                HeaderFieldGroup<ContactHeaderField> p = obj as HeaderFieldGroup<ContactHeaderField>;
                if((object)p == null)
                    {
                    return false;
                    }
                else
                    {
                    return p.Equals(this);
                    }
                }
            else
                {
                return this.Equals(p1);
                }
        }
        /// <summary>
        /// Parses string representation of the HeaderField.
        /// </summary>
        /// <remarks>  
        /// <b>RFC 3261 Syntax:</b> 
        /// <table >
        /// <tr><td colspan="2" style="border-bottom:none">("Contact" / "m" ) ":" ( STAR / (contact-param *("," contact-param)))</td></tr>
        /// <tr><td style="border-bottom:none">contact-param = </td><td style="border-bottom:none">(name-addr / addr-spec) *(SEMI contact-params)</td></tr>
        /// <tr><td style="border-bottom:none">name-addr = </td><td style="border-bottom:none">[ display-name ] &lt; addr-spec &gt;</td></tr>
        /// <tr><td style="border-bottom:none">addr-spec = </td><td style="border-bottom:none">SIP-URI / SIPS-URI / absoluteURI</td></tr>
        /// <tr><td style="border-bottom:none">display-name = </td><td style="border-bottom:none">*(token LWS)/ quoted-string</td></tr>
        /// <tr><td style="border-bottom:none">token = </td><td style="border-bottom:none">1*(alphanum / "-" / "." / "!" / "%" / "*" / "_" / "+" / "‘" / "'" / "˜" )</td></tr>
        /// <tr><td style="border-bottom:none">quoted-string = </td><td style="border-bottom:none">SWS DOUBLE_QUOTE *(qdtext / quoted-pair ) DOUBLE_QUOTE</td></tr>
        /// <tr><td style="border-bottom:none">qdtext = </td><td style="border-bottom:none">LWS / %x21 / %x23-5B / %x5D-7E / UTF8-NONASCII</td></tr>
        /// <tr><td style="border-bottom:none">LWS = </td><td style="border-bottom:none">[*WSP CRLF] 1*WSP ; linear whitespace</td></tr>
        /// <tr><td style="border-bottom:none">SWS = </td><td style="border-bottom:none">[LWS] ; sep whitespace</td></tr>
        /// <tr><td style="border-bottom:none">host = </td><td style="border-bottom:none">hostname / IPv4address / IPv6reference</td></tr>
        /// </table>
        /// <para/>
        /// <note type="implementnotes">The compact form of the Contact HeaderField is "m" (for "moved").</note> 
        /// <para/>
        /// <note type="implementnotes">This HeaderField allows HeaderField grouping (<see cref="T:Konnetic.Sip.Headers.HeaderFieldGroup{T}"/>).</note> 
        /// <example>
        /// <list type="bullet">
        /// <item>Contact: "Mr. Watson" &lt;sip:watson@worcester.bell-telephone.co&gt; ;q=0.7; expires=3600, "Mr. Watson" &lt;mailto:watson@bell-telephone.com&gt; ;q=0.1</item> 
        /// <item>m: &lt;sips:bob@192.0.2.4&gt;expires=60</item> 
        /// </list> 
        /// </example>
        /// </remarks>
        /// <param name="value">The HeaderField string to parse.</param>
        /// <exception cref="T:Konnetic.Sip.SipParseException">Thrown when an invalid (non-standard) value is encountered.</exception>
        /// <exception cref="T:Konnetic.Sip.SipException">Thrown when a processing exception is encountered.</exception>
        /// <threadsafety static="true" instance="false" />
        public override void Parse(string value)
        {
            if(value != null)
                {
                RemoveFieldName(ref value, FieldName, CompactName);
                Expires = null;
                QValue = null;
                base.Parse(value);
                Regex _uriRemove = new Regex(@"(?<=([^<]|\n)*)<?(sips?:)((.|\n)+@)?([^>\s\?]+)?([^>\s;]+)?>?", RegexOptions.Compiled | RegexOptions.IgnoreCase);
                value = _uriRemove.Replace(value, "").Trim();
                if(!string.IsNullOrEmpty(value))
                    {
                    float? newf = QValueHeaderFieldBase.ParseQValue(value);
                    if(newf >= 0)
                        {try{
                        QValue = newf;}
						catch(SipException ex)
							{
							throw new SipParseException("QValue", SR.ParseExceptionMessage(value), ex);
							}
						catch(Exception ex)
                            {
                            throw new SipParseException(SR.GetString(SR.GeneralParseException, newf, "QValue"), ex); 
							}
                        }
                    
                    Regex _expiresRegEx = new Regex(@"(?<=(.|\n)*expires\s*=\s*)[0-9]+", RegexOptions.Compiled | RegexOptions.IgnoreCase);

                    Match m = _expiresRegEx.Match(value);
                    if(m != null)
                        {
                        try
                            {
                            if(!string.IsNullOrEmpty(m.Value))
                                {
                                Int32 nVal = Int32.Parse(m.Value, CultureInfo.InvariantCulture);
                                Expires = nVal;
                                }
                            }
                        catch(SipException ex)
                            {
                            throw new SipParseException("Expires", SR.ParseExceptionMessage(value), ex);
                            }
                        catch(FormatException ex)
                            {
                            throw new SipParseException("Not a valid Expires.", ex);
                            }
                        catch(OverflowException ex)
                            {
                            throw new SipParseException(SR.GetString(SR.OverflowException, m.Value, "Expires"), ex);  
                            }
                        catch(Exception ex)
                            {
                            throw new SipParseException(SR.GetString(SR.GeneralParseException, m.Value, "Expires"), ex); 
                            }
                        }
                    }
                }
        }

        /// <summary>
        /// Initialises this instance.
        /// </summary>
        private void Init()
            {
            RegisterKnownParameter("expires");
            RegisterKnownParameter("q"); 
            AllowMultiple = true;
            FieldName = ContactHeaderField.LongName;
            CompactName = ContactHeaderField.ShortName;
        }

        #endregion Methods

 
    }
}